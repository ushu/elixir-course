<!-- livebook:{"file_entries":[{"name":"pattern-match-case.png","type":"attachment"},{"name":"terminal-rec-ok-ko.png","type":"attachment"}]} -->

# C1N3 ‚Äì Approfondissement sur les fonctions

```elixir
Mix.install([
  {:pythonx, "~> 0.4.2"},
  {:kino_pythonx, "~> 0.1.0"},
  {:kino, "~> 0.16.1"}
])
```

```pyproject.toml
[project]
name = "project"
version = "0.0.0"
requires-python = "==3.13.*"
dependencies = []
```

## Les fonctions et le pattern-matching

Jusqu'√† pr√©sent, nous avons explor√© les fonctions a travers des cas simples, en respectant toujours une m√™me syntaxe:

* la fonction est d√©finie une fois par module
* elle prend (en option) des arguments sous forme de variable
* son bloc, d√©fini entre les d√©limiteurs `do`...`end`, retourne sa derni√®re valeur

<!-- livebook:{"break_markdown":true} -->

Cette fa√ßon de faire fonctionne tr√®s bien, et permet de traiter des cas relativement complexes:

```elixir
defmodule Factorielle do

  def fact(n) do
    case n do
      0 -> 
        1
        
      n -> 
        n * fact(n-1)
    end  
  end
  
end

Factorielle.fact(4)
```

Le code ci-dessous, bien que parfaitement valide, n'est pas parfaitement idiomatique, ce cela pour plusieurs raison. Dans les _sections ci-dessous_, nous allons explorer de nouveaux √©l√©ments de syntaxe qui vont nous permettre de simplifier ce code, √©tape par √©tape.

<!-- livebook:{"break_markdown":true} -->

#### √âl√©ment de syntaxe n¬∞1 : le pattern matching dans la d√©claration de la fonction

Le code ci-dessus, via son `case`, r√©alise une op√©ration de "pattern matching" : c'est-√†-dire qu'il tente de faire correspondre la variable `n` avec une s√©rie de valeur successive (d'abord `0`, puis une valeur quelconque) afin de trouver une correspondance:

![](files/pattern-match-case.png)

Il est en fait possible de **r√©aliser cette op√©ration** directement au niveau de la d√©claration de la fonction, comme suit:

```elixir
defmodule FactorielleV2 do

  def fact(0) do
    1
  end

  def fact(n) do
     n * fact(n-1)
  end
  
end

FactorielleV2.fact(4)
```

ici nous avons apport√© deux modifications:

1. nous avons √©crit deux fois la m√™me fonction
2. dans la permi√®re "version" de la fonction nous avons remplac√© la variable `n` par la valeur constante `0`

Suite √† cette modification, Elixir va d√©sormer √©valuer `FactorielleV2.fact/1` comme suit:

* il va "tester" les diff√©rentes variantes de la fonction, **dans l'ordre o√π elle sont d√©finies** ("de haut en bas" dans le code) et ex√©cuter _la premi√®re fonction pour laquelle les argument "matchent" la valeur pass√©e en argument_
* dans le cas d'une r√©cursion ‚Äì cf. ligne 8 ci-dessus - il re-testera toutes les fonctions dans l'ordre

‚ö†Ô∏è **ATTENTION**: ce mode de fonctionnement, o√π Elixir teste nos fonctions jusqu'√† en trouver une qui convienne implique plusieurs comportements:

* si nous avions plac√© la variante `fact(n)` _au dessus_ de `fact(0)`, cette derni√®re _ne serait jamais appel√©e_: car `fact(n)` "branche toujours", `n` √©tant une variable libre qui accepte n'importe quelle valeur !
* si _aucune des variantes_ d'une fonction ne "branche", Elixir g√©n√®rera une erreur et le programme s'arr√™te

<!-- livebook:{"break_markdown":true} -->

#### √âl√©ment de syntaxe #2 : blocs d'une ligne

Quand le bloc ne contient qu'une expression simple, il est possible de _l'abr√©ger_:

* on remplace `do`...`end` par un argument `do:`
* et on place une virgule `,` avant ce `do:`

d√©monstration:

```elixir
defmodule FactorielleV3 do

  # le bloc do...end a disparu au profix de , do: ...
  #         üëá attention √† ne pas oublier cette virgule !
  def fact(0), do: 1

  #         üëá ni celle-l√† !
  def fact(n), do: n * fact(n-1)
  
end

FactorielleV3.fact(4)
```

## La r√©cursivit√© terminale

Elixir ‚Äì¬†comme OCaml... mais pas comme Python ‚Äì est capable d'optimiser les fonctions r√©cursives qui ont la propri√©t√© de _r√©cursivit√© terminale_, c'est-√†-dire:

* ce sont des fonctions r√©cursives
* la derni√®re op√©rations qu'elles r√©alisent est _soit_:
  * le renvoi d'une valeur constante
  * un appel r√©cursif √† elles-m√™me

<!-- livebook:{"break_markdown":true} -->

**Question**: nos questions ci-dessus (par ex. `FactorielleV3.fact/1`) ont-elles cette propri√©t√© de _r√©cusrivit√© terminale_ ?

_(r√©fl√©chissez un peu avant de scoller pour voir la r√©ponse üòâ)_

<div style="height: 100vh">

</div>

<!-- livebook:{"break_markdown":true} -->

Et bien la r√©ponse est **NON** !

en effet, la derni√®re op√©ration de notre fonction `fact()` n'est pas de s'appeler elle-m√™me, c'est la **multiplication**:

![](files/terminal-rec-ok-ko.png)

<!-- livebook:{"break_markdown":true} -->

Nous allons r√©-√©crire notre calcul de la factorielle pour utiliser cette r√©cursivit√© terminale.

Mais avant √ßa pr√©sentons un dernier √©l√©ment de syntaxe:

<!-- livebook:{"break_markdown":true} -->

#### √âl√©ment de syntaxe #3 : les fonctions _priv√©es_

En rempla√ßant `def` par `defp` lors de la d√©claration de fonctions dans nos modules, il est possible de cr√©er des fonctions priv√©es:

* elle sont appelables par les autres fonctions dans le m√™me modules
* mais ne sont pas accessible en dehors du module

D√©monstration:

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule PublicPrivateDemo do

  def public_f do
    IO.puts("Je suis une fonction publique")
    private_f()
  end

  #  üëá c'est le "p" de "defp" qui marque la fonction comme priv√©e
  defp private_f do
    IO.puts("Je suis une fonction priv√©e")
  end
  
end

# ‚úÖ cet appel va fonctionner, et la fonction priv√©e sera invoqu√©e
PublicPrivateDemo.public_f()

# üõë l'appel suivant ne fonctionnera pas
PublicPrivateDemo.private_f()
```

### Version "terminal recusrive" de la factorielle

Pour optimiser notre fonction factorielle, nous allons apporter deux modifications √† notre code:

* la fonction `fact/1` d√©l√®guera le calcul √† une fonction priv√©e `fact/2`
* cette derni√®re sera rendue terminal-recusrive en _rajoutant un argument "accumulateur"_

en pratique:

```elixir
defmodule FactorielleV4 do

  # Notre seule fonction "publique" d√©l√®gue √† la fonction priv√©e
  def fact(n), do: fact(n, 1)

  # √Ä la fin de la r√©cursion, on retourne l'accumulateur (second arg)
  defp fact(0, acc), do: acc

  #                            üëá le d√©cr√©ment du compteur
  defp fact(n, acc), do: fact(n-1, n * acc)
  #                      ‚Üë           üëÜ le produit du calcul
  #                      ‚îî on appelle "fact" en dernier !
  
end

FactorielleV4.fact(4)
```

## Exercice pratique

√âcrivez un module simple qui calcule le ni√®me terme de la [suite de Fibonacci](https://fr.wikipedia.org/wiki/Suite_de_Fibonacci).

Pour rappel:

$$ F_{0}=0 $$

$$ F_{1}=0 $$

$$ F_{n+2}=F_{n+1}+F_n $$

Vous pouvez faire plusieurs variantes:

```elixir
defmodule TP3Exercice1 do

  @doc """
  Calcule le n-i√®me terme de la suite de Fibonacci

  ## Exemple

    iex> TP3Exercice1.fib(2)
    1

    iex> TP3Exercice1.fib(3)
    2

    iex> TP3Exercice1.fib(10)
    55
  """
  def fib(b) do
    0 # TODO
  end
  
end
```

## L'op√©rateur "pipe"

Il est souvent n√©cessaire d'encha√Æner les appels de fonctions les une apr√®s les autres, afin d'apporter des modifications successives √† une donn√©e de d√©part.

Prenons un exemple pratique : imaginons que nous travaillions sur un syst√®me de blog. L'utilisateur peut cr√©er des articles, et d√©finir le titre du nouvel article. Puis arrive le moment de la publication et nous souhaiterions g√©n√©rer une adresse "explicite" pour ce post, par ex:

* si l'utilisateur a √©crit un post nomm√© "Mon premier blog-post"
* nous aimerions que l'adresse internet de l'article soit "mon-premier-blog-post"

Pour se faire, nous imaginons un algorithme:

* nous partons du titre et le mettons en minuscue
* puis nous s√©parons les mots en "coupant" au niveau des espaces
* enfin nous "regroupons" les morceaux en les relitant avec des tirets `-`

En Python:

```python
titre_article = "Mon premier blog post"

    # la m√©thode .join() de ste
"-".join(
  titre_article
    .lower()    # transforme la str en minuscule
    .split(" ") # coupe la str en une list de str
)
```

Essayons maintenant de faire la m√™me chose en Elixir:

```elixir
titre_article = "Mon premier blog post"

Enum.join(
  String.split(
    String.downcase(
      titre_article    
    ),
    " "
  ),
  "-"
)
```

ce n'est pas extr√™mement lisible...

Une alternative possible serait de passer par une variable que l'on r√©-assignerait au fur et √† mesure des transformations:

```elixir
titre_article = "Mon premier blog post"

slug = String.downcase(titre_article)
slug = String.split(slug, " ")
slug = Enum.join(slug, "-")
slug
```

Beaucoup mieux !

Nous voyons l√† les forces et les faiblesse de l'approche "objet" de Python:

* il est facile "d'encha√Æner" les appels des _m√©thodes_ de `str` telles que `.lower()` et `.split()`
* la "cha√Æne de caract√®re courante" est pass√©e implicitement : le langage "sait" que nous travaillons sur `titre_article`
* par contre, √ßa ne fonctionne pas lorsque la fonction √† appeler ne fait pas partie des m√©thodes de `str` : dans le code Python plus haut, nous avons finalement besoin de faire un `.join()` mais cette m√©thode n'est pas disponible, et on ne peut pas "encha√Æner l'appel avec `.`"

Elixir propose **une syntaxe dite de "pipe" `|>`** qui permet de faire sensiblement la m√™me chose:

* le r√©sultat de la fonction pr√©c√©dente est implicitement pass√© comme premier argument de la fonction suivante
* on peut mettre n'importe quelle fonctions "√† la suite", contrairement aux objets ou seules mes _m√©thodes de la classe_ peuvent √™tre "cha√Æn√©es"

D√©monstration:

```elixir
titre_article = "Mon premier blog post"

titre_article
|> String.downcase()  # titre_article est pass√© en argument implicitement
|> String.split(" ")  # idem pour le r√©sultat de downcase
|> Enum.join("-")     # et de join
```

**BONUS**: debug des encha√Ænements d'op√©rations

Elixir dispose d'une macro `dbg` qui permet d'analyser ce qui se passe √† l'int√©rieur d'une suite d'op√©rations. Cette fonctionnalit√© est particuli√®rement bien int√©gr√©e √† LiveBook.

Pour l'utiliser il suffit de _rajouter une √©tape de pipe vers `dbg()`_:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
titre_article
|> String.downcase()
|> String.split(" ")
|> Enum.join("-")
|> dbg()
```

### Exercice d'application

Commencez par **parcourir rapidement la documentation du [module `Enum` d'Elixir](https://hexdocs.pm/elixir/1.18.4/Enum.html)** qui permet de travailler sur les collections (et les listes en particulier).

## Les fonctions anonymes

Elixir dispose d'un √©quivalent aux `lambda`s de Python: c'est-√†-dire une fa√ßon de d√©finir une fonction qui n'a pas de nom (et qui _n'appartient pas √† un module_ !).

Cette syntaxe se pr√©sente comme suit:

* le mot-cl√© `fn`
* suivi (√©ventuellement), d'une liste d'arguments
* suivi d'une "fl√®che" `->`
* et enfin le mot-cl√© `end` √† la fin de la d√©claration

```elixir
# Exemple de fonction, mise dans la variable ma_f
elixir_anon_f = fn x -> 
  x+1
end
```

est √©quivalent √† la d√©claration Python:

```python
python_anon_f = lambda x: x+1
```

on peut v√©rifier que cette variable contient bien une fonction:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
is_function(elixir_anon_f)
```

et on peut l'**invoquer**.

‚ö†Ô∏è **ATTENTION** quand on √©voque une fonction anonyme, il faut rajouter un `.` avant les parenth√®ses !

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
elixir_anon_f.(10)
```
