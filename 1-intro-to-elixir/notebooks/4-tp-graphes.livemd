# C1TP â€“ Parcours dâ€™un labyrinthe

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:phoenix_live_view, "~> 1.1"}
])

ExUnit.configure(exclude: [:skip])
ExUnit.start(autorun: false)
```

## Objectif(s)

* Manipuler les **listes** et **maps**.
* ImplÃ©menter un **algorithme simple** (parcours en largeur ou profondeur).
* DÃ©couvrir une reprÃ©sentation **graphique / automate** dâ€™un problÃ¨me.
* Ã‰crire et composer des **fonctions**.

## 1. ReprÃ©senter un graphe

### Quâ€™est-ce quâ€™un graphe ?

Un **graphe** $G = (V, E)$ est un couple constituÃ© :

* dâ€™un ensemble $V$ de **sommets** (ou nÅ“uds),
* dâ€™un ensemble $E \subseteq \{ \{u, v\} \mid u, v \in V, u \ne v \}$ de **paires non ordonnÃ©es** appelÃ©es **arÃªtes** (ou liens).

On parle alors de **graphe non orientÃ©** et **simple** (sans boucles ni arÃªtes multiples).

#### Exemple :

$$
V = \{A, B, C, D\}, \quad E = \{\{A,B\}, \{A,D\}, \{B,C\}, \{C,D\} \}
$$

correspond au graphe suivant:

```mermaid
graph LR
  A --- B
  A --- D
  B --- C
  C --- D
```

<!-- livebook:{"break_markdown":true} -->

### ReprÃ©sentation informatique du graphe

Il existe beaucoup de maniÃ¨re de reprÃ©senter un graphe.
On peut le reprÃ©senter par une **carte** (graphe dessinÃ©, voir ci-dessous), par un ensemble de "noeuds" dans la mÃ©moire de l'ordinateur, par une **liste dâ€™adjacence**, ou encore une **matrice dâ€™adjacence**.

Dans ce TP, nous utilisons la **liste dâ€™adjacence**, qui consiste Ã  associer Ã  chaque noeud du graphe la liste des noeuds qui le suivent.

Toujous sur notre exemple, cela donnerait:

```elixir
graphe_simple = %{
  "A": [ "B", "D" ], # Les "successeurs de A sont B et D
  "B": [ "C" ],      # Le successeur de B est D
  "C": [ "D" ],      # Le successeur de C est D
}
```

### Un graphe plus complet

On considÃ¨re un petit comme celui-ci pour reprÃ©senter notre labyrinthe :

```mermaid
graph LR
  classDef start fill:#dff,stroke:#06c,stroke-width:2px;
  classDef goal  fill:#ffd,stroke:#c60,stroke-width:2px;

  A:::start <--> B <--> C
  A <--> D
  B <--> E
  D <--> E <--> F:::goal
  C <--> F
```

<!-- livebook:{"break_markdown":true} -->

On peut le reprÃ©senter par une **liste dâ€™adjacence** :

```elixir
graph = %{
  "A" => ["B", "D"],
  "B" => ["A", "C", "E"],
  "C" => ["B", "F"],
  "D" => ["A", "E"],
  "E" => ["B", "D", "F"],
  "F" => ["C", "E"]
}

%{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
```

ğŸ’¡ _on remarquera que dans ce cas, le graphe n'est pas "orientÃ©": s'il est permis d'aller de $A$ vers $B$, alors ils est permis d'aller de $B$ vers $A$_

<!-- livebook:{"break_markdown":true} -->

### Ã‰crire une fonction `GraphInfo.neighbors/2` qui renvoie la liste des voisins dâ€™un nÅ“ud.

âš ï¸ Dans le cas oÃ¹ aucune arrÃªte n'est spÃ©cifiÃ©e pour un noeud, on renverra une liste vide `[]`

ğŸ’¡ Pensez Ã  consulter la [documentation du module `Map`](https://hexdocs.pm/elixir/Map.html) au besoin

```elixir
defmodule GraphInfo do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "A")
    ["B", "D"]

    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []

  """
  def neighbors(graph, node) do
    []
  end
  
end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphInfoCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfoCorrige.neighbors(graph, "A")
    ["B", "D"]
    
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"] }
    iex> GraphInfo.neighbors(graph, "C")
    []
  """
  def neighbors(graph, node) do
    Map.get(graph, node, [])
  end
  
end
```

## 2. Parcours en largeur (BFS)

Nous voulons dÃ©sormais parcourir notre graphe "en largeur, c'est Ã  dire:

* on donne Ã  notre fonction un un graph et un noeud de dÃ©part
* il retourne une liste de tous les noeuds, parcourus Ã  partir du noeud courant (voir exemple dans le DocTest)

N'hÃ©sitez pas Ã  demander de l'aide Ã  votre encadrant et/ou Ã  vous renseigner sur l'algorithme sur internet.

Pour votre code, vous pourriez utiliser:

* l'opÃ©rateur `in` qui permet de tester si un Ã©lÃ©ment est dans une liste: `1 in [1, 2, 3, 4]`
* la concatÃ©nation de deux listes avec `++`: `[1, 2] ++ [3, 4] == [1, 2, 3, 4]`
* la fonction `Enum.reverse` qui "retourne" une liste

```elixir
defmodule GraphBFS do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFS.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    []
  end
  
end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphBFSCorrige do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphBFSCorrige.bfs(graph, "A")
    ["A", "B", "D", "C", "E", "F"]
  """
  def bfs(graph, start) do
    bfs(graph, [start], [])
  end

  defp bfs(_graph, [], visited), do: Enum.reverse(visited)
  
  defp bfs(graph, [current | rest], visited) do
    dbg(visited)
    if current in visited do
      bfs(graph, rest, visited) # dÃ©jÃ  visitÃ©
    else
      new_nodes = GraphInfoCorrige.neighbors(graph, current)
      bfs(
        graph, 
        rest ++ new_nodes, # on "enqueue" les noeuds Ã  visiter
        [current | visited] # et on rajoute le noeud visite dans la liste
      )
    end
  end
  
end
```

```elixir
GraphBFSCorrige.bfs(graph, "A")
```

## 3. Plus cours chemin (greedy)

Votre objectif ici est de _reprendre votre code de parcours en largeur_ afin de trouver le plus cours chemin vers un point "objectif":

* on parcours toujours le graphe en largeur
* au lieu de ne stocker que les noeuds, on stocke les noeuds et le chemin qui mÃ¨ne Ã  ce noeud (par ex. dans un tuple)
* quand on arrive Ã  l'objectif on a trouvÃ© le chemin le plus cours (c'est le plus court grÃ¢ce au parcours en largeur)

Ã€ vous de jouer:

```elixir
defmodule GraphShortestPath do

  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestPath.shortest_path(graph, "A", "C")
    ["A","B","C"]
  """
  def shortest_path(graph, start, goal) do
    []
  end
  
end
```

```elixir
# CORRECTION POSSIBLE

defmodule GraphShortestCorrige do
  @doc """
    iex> graph = %{ "A" => ["B", "D"], "B" => ["A", "C", "E"], "C" => ["B", "F"], "D" => ["A", "E"], "E" => ["B", "D", "F"], "F" => ["C", "E"] }
    iex> GraphShortestCorrige.shortest_path(graph, "A", "C")
    ["A","B","C"]  
  """
  def shortest_path(graph, start, goal) do
    shortest_path(graph, [{start, [start]}], goal, [])
  end

  defp shortest_path(_graph, [], _goal, _visited), do: nil

  defp shortest_path(graph, [{current, path} | rest], goal, visited) do
    dbg(visited)
    cond do
      current == goal ->
        # on a trouvÃ© !
        path

      current in visited ->
        # on skip le noeud
        shortest_path(graph, rest, goal, visited)

      true ->
        new_nodes_with_path =
          GraphInfoCorrige.neighbors(graph, current)
          |> Enum.map(fn n ->
            # on crÃ©e les tuples { noeud, chemin }
            {n, path ++ [n]}
          end)

        shortest_path(graph, rest ++ new_nodes_with_path, goal, [current | visited])
    end
  end
end
```

```elixir
data = %{
  id: 1,
  email: "user@example.com",
  inserted_at: ~U[2022-01-01T10:00:00Z],
  addresses: [
    %{
      country: "pl",
      city: "KrakÃ³w",
      street: "Karmelicka",
      zip: "00123"
    }
  ]
}

Kino.Tree.new(data)
```
