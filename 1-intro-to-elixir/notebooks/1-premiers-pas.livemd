<!-- livebook:{"file_entries":[{"name":"cell-results.png","type":"attachment"},{"name":"help-jump.png","type":"attachment"},{"name":"hover-doc.png","type":"attachment"},{"name":"lb-completion.png","type":"attachment"},{"name":"module-outline.png","type":"attachment"},{"name":"nargs-in-signature.png","type":"attachment"},{"name":"run-icon.png","type":"attachment"},{"name":"same-name-diff-arity.png","type":"attachment"}]} -->

# C1N1 ‚Äì Premiers pas avec Elixir

```elixir
Mix.install([
  {:pythonx, "~> 0.4.2"},
  {:kino_pythonx, "~> 0.1.0"}
])
```

```pyproject.toml
[project]
name = "project"
version = "0.0.0"
requires-python = "==3.13.*"
dependencies = []
```

## Votre premier exemple de code Elixir

Reprenons l'exemple pr√©sent√© dans les transparents du cours:

* vous pouvez **ex√©cuter** ce code en passant par votre souris au-dessus de la cellule et cliquer l'ic√¥ne ‚ñ∂Ô∏è situ√©e en haut √† gauche ![](files/run-icon.png)
* vous pouvez √©galement passer votre pointeur de souris sur le module `IO` ou la fonction `puts` afin d'afficher la documentation associ√©e ![](files/hover-doc.png)

```elixir
IO.puts("Hello, world !")
```

L'ex√©cution de cette cellule affiche deux r√©sultats:

![](files/cell-results.png)

Le `"Hello, world !"` est la valeur imprim√©e dans la console (comme un `print()` en Python) et correspond bien √† la cha√Æne de caract√®res pass√©e en argument.

Le seconde valeur affich√©e ‚Äì le `:ok` ‚Äì est la valeur renvoy√©e par l'appel √† la fonction `IO.puts/1` que nous avons ex√©cut√©e. Il s'agit d'une constante Elixir (un _atome_) comme nous le verrons plus tard dans ce cours.

## Prise en main: Elixir c'est comme Python üöÄ

Afin de faciliter la prise en main du langage, nous allons commencer par explorer plusieurs **types de donn√©es** simples et plusieurs fonctions disponibles dans la librairie standard d'Elixir.

L'objectif de cette section du cours est donc:

* de continuer √† vous familiariser avec LiveBook
* de profiter des similitudes du langage Elixir avec le langage Python que vous connaissez afin de commencer rapidement √† l'utiliser
* d'apprendre √† parcourir la documentation d'Elixir

<!-- livebook:{"break_markdown":true} -->

### Les types num√©riques en Elixir

Nous retrouvons en Elixir les m√™mes types num√©riques qu'en Python: √† savoir les nombres entiers, et les nombres flottants. Comme vous le constaterez √† l'usage, la syntaxe pour d√©finir des variables et pour faire des calculs est tr√®s semblable √† celle de Python.

Commencez par √©valuer la cellule suivante:

```elixir
# une valeure enti√®re
a = 2
a + a
```

```elixir
# une valeur en nombre flottant
b = 3.14
3 * b
```

üí° l'op√©rateur _division_ `/` effectue retourne une valeur flottante. Pour obtenir une division enti√®re et/ou un reste il faudra utiliser les op√©rateurs [`div` (comme "divide")](https://hexdocs.pm/elixir/Kernel.html#div/2) et [`rem` (comme "reminder")](https://hexdocs.pm/elixir/Kernel.html#rem/2):

```elixir
div(10, 3)
```

```elixir
rem(10, 3)
```

```elixir
10 == 3 * div(10, 3) + rem(10, 3)
```

### Un petit exercice

Commencez par lire la documentation Elixir disponible en ligne:

* la section "Basic arithmetic" disponible [ici](https://hexdocs.pm/elixir/basic-types.html#basic-arithmetic)
* la documentation de l'op√©rateur `**/2` disponible [ici](https://hexdocs.pm/elixir/Kernel.html#**/2)
* la documentation de l'op√©rateur `abs/1` disponible [ici](https://hexdocs.pm/elixir/Kernel.html#abs/1)

En rempla√ßant les appels `print()` de Python par des appels √† `IO.puts`, traduisez le code suivant en Elixir:

```python
# valeur au cube
print(10 ** 3)
# arrondi
print(round(3.14))
# valeur absolue
print(abs(-44))
```

```elixir
# √† vous de jouer !
```

<!-- livebook:{"branch_parent_index":0} -->

## Ma premi√®re fonction

Elixir fait partie des langages dits "fonctionnels". Cette famille de langage peut parfois √™tre complexe √† appr√©hender lorsque les langages en question disposent en plus de syst√®mes de types complexes, comme c'est le cas d'OCaml que certains d'entre vous ont √©tudi√© en pr√©pa.

Heureusement pour nous, Elixir est certes un langage fonctionnel, mais ce n'est pas un langage typ√©. Ainsi ‚Äì comme vous avez pu le constater ‚Äì son usage ressemble beaucoup √† celui de Python, en particulier gr√¢ce √† la d√©claration des variables "au fil de l'eau" sans avoir besoin d'en pr√©ciser la nature au pr√©alable.

Ceci √©tant dit, en tant que langage fonctionnel, les fonctions ont une place absolument centrale dans la programmation en Elixir. Dans ce qui suit, nous allons explorer une des facons de d√©finir une fonction, puis nous d√©couvrirons au fur et √† mesure de notre apprentissage d'autres approches et raccourcis syntaxiques disponibles dans le langage.

<!-- livebook:{"break_markdown":true} -->

Comme √©voqu√© lors de la pr√©sentation des transparents de cours, les fonctions Elixir sont regroup√©es dans des **modules**. Ainsi pour pouvoir d√©clarer notre fonction, nous devront:

* cr√©er un **module**: avec `defmodule`
* cr√©er notre **fonction** _dans_ ce module: avec `def`

en pratique:

```elixir
defmodule MonPremierModule do

  def ma_premiere_fonction do
    IO.puts("Bonjour je suis la fonction")
  end

end
```

on remarque plusieurs choses:

* le "contenu" du module et de la fonction est d√©limit√© par un "bloc" qui commence par `do` et se termine par `end`
* le nom du module est une suite de mots commen√ßant par une majuscule et coll√©s entre eux (on parle de "Pascal Case")
* le nom de la fonction est une suite de mots en minuscule reli√©s par des `_` (on parle de "Snake Case")

Ces conventions (en particulier sur le nom de module) sont √† respecter lorsque l'on programme en Elixir.

<!-- livebook:{"break_markdown":true} -->

Une fois la cellule contenant votre fonction ex√©cut√©e, celle-ci devient disponible √† l'ex√©cution, et l'√©diteur Elixir inclus dans LiveBook va automatiquement vous proposer de compl√©ter la saisie:

![](files/lb-completion.png)

De plus, le module ainsi d√©fini appara√Æt automatiquement dans la table des mati√®res ("outline") disponible dans le menu de gauche du LiveBook: il vous suffit de cliquer dessus pour "sauter" vers cette cellule.

![](files/module-outline.png)

Enfin, il est int√©ressant de noter que la documentation automatique qui appara√Æt lorsque le curseur de la souris survole un nom de fonction ou de module permet √©galement de sauter vers la d√©finition:

* s'il s'agit d'une fonction d√©finit dans le livebook courant, il est possible de sauter vers la cellule qui l'a d√©finie
* s'il s'agit d'une fonction de la librairie standard, il est possible de sauter directement vers la documentation de ladite fonction

![](files/help-jump.png)

il est temps d'appeler notre fonction:

```elixir
MonPremierModule.ma_premiere_fonction()
```

### Arguments des fonctions

Il est possible de passer des arguments √† nos fonctions, d'une mani√®re tr√®s semblable √† ce que propose Python.

Pour se faire, vous pouvez ajouter votre liste de param√®tres entre parenth√®ses √† la d√©claration, puis les rappeler au moment de l'appel, exemple:

```elixir
defmodule MonDeuxiemeModule do

  def ajoute_et_un(x, y) do
    x + y + 1
  end

end
```

```elixir
MonDeuxiemeModule.ajoute_et_un(1, 2)
```

Cet exemple appelle plusieurs remarques:

* tout d'abord, _contrairement_ √† Python il n'y a pas d'appel √† `return` pour renvoyer un r√©sultat: la derni√®re expression d'un bloc (entre `do` et `end`) et renvoy√©e et constitue le r√©sultat de la fonction
* les plus observateurs d'entre vous auront peut-√™tre remarqu√©s que lorsque LiveBook compl√®te le nom de la fonction, il rajoute `/2` √† la fin du nom: ![](files/nargs-in-signature.png)
  Il s'agit en fait du **nombre d'arguments** que prend la fonction !

Ce dernier point illustre une diff√©rence fondamentale entre Python et Elixir: en Python, si on re-d√©finit une fonction avec le m√™me nom qu'une fonction existante , on "√©crase" la premi√®re fonction qui devient donc inaccessible.
Elixir, on contraire, permet d'avoir plusieurs fonctions ayant le m√™me nom _pourvu qu'elles n'aient pas le m√™me nombre de param√®tres_. Et c'est pour cel√† que le nombre de param√®tre _fait partie du nome de la fonction_.

En pratique:

```elixir
defmodule MonTroisiemeModule do

  def add_et_un(x, y) do
    x + y + 1
  end

  def add_et_un(x) do
    x + x + 1
  end

end
```

Elixir d√©tecte bien les deux variantes de cette fonction, comme le prouve LiveBook:

![](files/same-name-diff-arity.png)

et on peut les appeler s√©par√©ment, ce qui aurait √©t√© impossible en Python:

<!-- livebook:{"continue_on_error":true} -->

```python
def add_et_un(x, y):
  return x + y + 1

def add_et_un(x):
  x + x + 1

add_et_un(1, 2) # üëà la version √† deux arguments "n'existe plus" !
```

### √Ä vous de jouer

D√©finissez un module permettant de convertir les degr√©s Celsius en degr√©s Farenheight et inversement.

La formule de conversion, telle que donn√©e sur [Wikipedia](https://fr.wikipedia.org/wiki/Degr√©_Fahrenheit) est: $$T\text{(¬∞F)} = \frac{9}{5}T\text{(¬∞C)} + 32$$.

üí° Vous trouverez ci-dessous un squelette de code √† compl√©ter. Ce dernier vous pr√©sente des fonctionnalit√©s suppl√©mentaires d'Elixir et Livebook, √† savoir:

* la possibilit√© de documenter une fonction en ajoutant un attribut `@doc` suivi d'une chaine de caract√®res juste avant la d√©claration de la fonction
* la possibilit√© d'√©crire des chaines de carat√®res de plusieurs lignes, via les "triples quotes" (similaires √† [ce qui existe en Python](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str))
* enfin, la possibilt√© d'inclure des tests simples dans cette documentation: il s'agit des [DocTests Elixir](https://hexdocs.pm/elixir/docs-tests-and-with.html#doctests) qui sont tr√®s proches des [doctest Python](https://docs.python.org/3/library/doctest.html)

```elixir
defmodule FahrenheitConverter do

  @doc """
  Convertit les degr√©s celsius en fahrenheit

  ## Exemple

      iex> FahrenheitConverter.c_to_f(0.0)
      32.0

      iex> FahrenheitConverter.c_to_f(100.0)
      212.0
  """
  def c_to_f(celsius) do
    0.0 # √Ä COMPL√âTER
  end

  @doc """
  Convertit les degr√©s celsius en fahrenheit

  ## Exemple

      iex> FahrenheitConverter.f_to_c(32)
      0.0

      iex> FahrenheitConverter.f_to_c(212.0)
      100.0
  """
  def f_to_c(fahrenheit) do
    0.0 # √Ä COMPL√âTER
  end

end
```

<!-- livebook:{"branch_parent_index":0} -->

## Quelques notions sur les cha√Ænes de caract√®res

Nous avons d√©j√† vu comment d√©finir une cha√Æne de carat√®res en Elixir:

```elixir
"Bonjour, je suis une cha√Æne de caract√®res"
```

Elixir dispose ‚Äì comme Python d'ailleurs ‚Äì d'un support tr√®s complet pour travailler avec des donn√©s textuelles. En particulier, le [module String](https://hexdocs.pm/elixir/1.14/String.html) propose toute une s√©rie de fonctions pour manipuler les cha√Ænes de caract√®res qui peuvent se r√©v√©ler bien pratiques.

**Cependant** le support d'Elixir des cha√Ænes de caract√®res est assez diff√©rent de celui de Python car plus "bas niveau". Sans entrer trop dans les d√©tails ‚Äì pour l'instant ‚Äì une cha√Æne de caract√®res est un tableau d'octets en m√©moire, que l'on peut interpr√©ter comme une suite de caract√®res selon une nombre d'encodage appel√©e [Unicode](https://fr.wikipedia.org/wiki/Unicode).

Lorsque vous d√©finissez une cha√Ænes de caract√®res en Elixir, vous d√©finissez en fait un tableau de valeurs qui est √† la fois:

* une `bitstring` c'est-√†-dire un tableau de "bits" (0 ou 1 en m√©moire)
* un `binary` c'est-√†-dire une bitstring d'octets (dont la taille est multiple de 8)
* et finalement ce `binary` contient du texte en Unicode

On peut facilement v√©rifier toutes ces assetions via des fonctions d√©di√©es:

```elixir
is_bitstring("Je suis une cha√Æne de caract√®res, c'est √† dire un tableau de bits en m√©moire")
```

```elixir
is_binary("Je suis une cha√Æne de caract√®res, c'est √† dire un tableau d'octets en m√©moire")
```

```elixir
String.valid?("Je suis une cha√Æne de caract√®res, c'est √† dire un tableau caract√®res Unicode")
```

‚ö†Ô∏è **ATTENTION** en Elixir, il faut utiliser les guillements "doubles" et non les guillements simples `'` accept√©s en Python ! Pour en savoir un peu plus, vous pouvez consulter la [documentation officielle](https://hexdocs.pm/elixir/binaries-strings-and-charlists.html).

<!-- livebook:{"break_markdown":true} -->

### Concat√©nation de cha√Ænes de caract√®res

l'op√©rateur `<>` permet de concat√©ner des cha√Ænes de caract√®res ‚Äì en r√©alit√© il concat√®ne n'importe quel `binary` en m√©moire, mais √† notre niveau on ne l'utilisera que pour des cha√Ænes de caract√®res ‚Äì tr√®s facilement:

```elixir
"Bonjour " <> "le" <> " monde"
```

En g√©n√©ral, on lui pr√©f√®rera une autre syntaxe qui se rapproche des ["format strings" de Python](https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings):

```elixir
bonjour = "Bonjour"
le = "le"
monde = "monde"

"#{bonjour} #{le} #{monde}"
```

Attention cependant: contrairement √† Python qui dispose d'une librairie tr√®s compl√®te pour "formatter" diff√©rentes valeurs, dans ses format strings, l'interpolation standard d'Elixir se limite √† concat√©ner les valeurs telles quelles.

_Pour formatter des cha√Ænes de carat√®res de fa√ßon "avanc√©e", il faudrait utiliser les [fonctionnalit√©s d'Erlang](https://www.erlang.org/doc/apps/stdlib/io.html#fwrite/3) (le syst√®me sous-jacent √† Elixir) ce qui se fait tr√®s bien mais d√©passe largement le cadre ce ce TP üòÖ_

<!-- livebook:{"branch_parent_index":0} -->

## Exercice final

Il est temps de r√©aliser un programme un peu plus cons√©quent.

Pour r√©aliser cet exercice, vous aurez besoins de fonctions disponibles:

* au sein du [module `Integer`](https://hexdocs.pm/elixir/Integer.html)
* au sein du [module `String`](https://hexdocs.pm/elixir/String.html)

Votre mission sera donc de cr√©er un module permettant de formater un temps donn√© en secondes sous forme d'une cha√Æne de caract√®res `"HH:MM:SS"`

```elixir
defmodule TimeTools do
  @moduledoc """
  Outils de conversion de temps (secondes <-> texte HH:MM:SS).
  """

  @doc """
  Convertit un nombre de secondes en une cha√Æne "HH:MM:SS"
  avec padding sur 2 chiffres.

  ## Exemples

    iex> TimeTools.seconds_to_hms(0)
    "00:00:00"

    iex> TimeTools.seconds_to_hms(10)
    "00:00:10"

    iex> TimeTools.seconds_to_hms(90)
    "00:01:30"

    iex> TimeTools.seconds_to_hms(86400)
    "24:00:00"
  """
  def seconds_to_hms(total_seconds) do
    h = "00"
    m = "00"
    s = "00"

    "#{h}:#{m}:#{s}"
  end
end
```

---

Vous √™tes arriv√©s au bout de ce notebook, **f√©licitations** üéâ

Rendez-vous [au notebook suivant](2-aller-plus-loin.livemd) pour continuer votre apprentissage d'Elixir !

---

## Exercices suppl√©mentaires

Les petits exercices suivants sont _optionnels_ et uniquement l√† dans le but de _pratiquer_ la programmation Elixir, _si vous avez le temps_.

<!-- livebook:{"break_markdown":true} -->

### Salutations

Dans cette exercice, vous devez √©crire une fonction `salutation/1` qui, lorsqu'on lui donne un pr√©nom, va renvoyer "Bonjour, <pr√©nom> !".

```elixir
defmodule TP1ExerciceOpt1 do

  @doc """
  Renvoie une cha√Æne de caract√®res, au bon format !

  ## Exercices

    iex> TP1ExerciceOpt1.salutation("Alice")
    "Bonjour, Alice !"

    iex> TP1ExerciceOpt1.salutation("Bob")
    "Bonjour, Bob !"
  """
  def salutation(nom) do
    ""
  end
end
```
