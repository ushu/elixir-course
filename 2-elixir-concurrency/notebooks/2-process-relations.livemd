<!-- livebook:{"file_entries":[{"name":"missing-link.png","type":"attachment"},{"name":"process-down-error.png","type":"attachment"},{"name":"process-down.png","type":"attachment"},{"name":"stop-button-cell.png","type":"attachment"}]} -->

# C2N2 ‚Äì Relation entre les processus

```elixir
Mix.install([
  {:kino, "~> 0.16.1"},
  {:benchee, "~> 1.4"},
  {:kino_benchee, "~> 0.1.0"}
])
```

## D√©tection de l'arr√™t des processus

Jusqu'√† maintenant, nous avons consid√©r√©s des processus compl√®tement ind√©pendants les uns des autres. Si un de ces processus s'arr√™te - par exemple car sa fonction se termine, ou √† cause d'une erreur √† l'ex√©cution ‚Äì aucun autre processus n'est averti de cet arr√™t et le bon fonctionnement du programme peut-√™tre compromis: typiquement si un processus "parent" attend une r√©ponse d'un processus "enfant" interrompu qui n'arrivera jamais.

Pour palier ce probl√®me, il est possible de "monitorer" les processus afin d'√™tre averti en cas d'arr√™t intempestif:

<!-- livebook:{"break_markdown":true} -->

### [`Process.monitor/1`](https://hexdocs.pm/elixir/Process.html#monitor/1) pour l'√©coute du cycle de vie d'un processus

Le module [`Process`](https://hexdocs.pm/elixir/Process.html) dispose de nombreuses fonctions destin√©es √† agir directement sur les processus Elixir: arr√™t forc√©, cr√©ation d'alias etc. Nous serons amen√© √† explorer plusieurs de ces fonctionnalit√©s durant ce cours au fur et √† mesure que nous approfondirons ces notions.

La fonction [`Process.monitor/1`](https://hexdocs.pm/elixir/Process.html#monitor/1) dont nous allons parler maintenant a une fonction tr√®s particuli√®re: elle permet √† un processus d'√™tre inform√© du moment o√π le processus cicle s'arr√™te.

Commen√ßons par un exemple pratique, que nous allons d√©cortiquer:

```elixir
enfant = spawn(fn -> 
  IO.puts "Message du processus enfant"
end)

# On lance le "monitoring" du processus enfant, par le processus courant (self())
Process.monitor(enfant)

receive do
  msg -> 
    IO.inspect msg, label: "Message re√ßu par le parent"
end
```

On peut r√©sumer le fonctionnement observ√© par la s√©quence suivante:

* nous avons lanc√© le processus enfant (c-√†-d. demand√© √† la VM BEAM de cr√©er un processus et d'y ex√©cuter notre fonction)
* puis nous avons demand√© √† ce que le process courant (self()) monitore ce nouveau processus
* le processus s'est ex√©cut√© et √† affich√© "`Message du processus enfant`" dans le Terminal de (la cellule du) Livebook
* le processus s'est termin√©
* la VM BEAM a inform√© le processus qui monitorait `enfant` (donc `self`) de l'arr√™t de ce processus via un message d√©di√©

```mermaid
sequenceDiagram
    autonumber
    participant P as Parent (self)
    participant C as Enfant (spawn)
    participant VM as BEAM/VM

    Note over P: Le parent cr√©e un processus enfant
    P->>C: spawn(fn -> IO.puts("Message du processus enfant") end)
    activate C

    Note over P: Le parent d√©marre un monitor sur C
    P->>VM: Process.monitor(C)
    VM-->>P: ref = #Reference<...>

    Note right of C: L‚Äôenfant s‚Äôex√©cute puis se termine (raison: :normal)
    C-->>C: IO.puts("Message du processus enfant")
    deactivate C

    Note over VM: √Ä la terminaison de C, la VM notifie le parent
    VM-->>P: {:DOWN, ref, :process, pid(C), :normal}

    Note over P: Le parent re√ßoit et inspecte le message
    P->>P: receive do msg -> IO.inspect(msg) end
```

<!-- livebook:{"break_markdown":true} -->

Cette s√©quence se termine donc par l'envoi d'un message, qui s'est affich√© lors de l'ex√©cution de la cellule pr√©c√©dente et se d√©compose comme suit:

![](files/process-down.png)

observons maintenant ce qu'il se passe si le process s'arr√™te √† cause d'un dysfonctionnement. Pour cela nous allons utiliser la commande [`raise/1`](https://hexdocs.pm/elixir/Kernel.html#raise/1) d'Elixir qui va arr√™ter le processus courant avec une _excpetion_ (de type [`RuntimeError`](https://hexdocs.pm/elixir/RuntimeError.html) par d√©faut):

```elixir
enfant = spawn(fn -> 
  IO.puts "Attention je vais lever une exception"
  raise "This is a crash"
end)

Process.monitor(enfant)

receive do
  msg -> msg
end
```

le message re√ßu par dans le cadre du monitoring est identique au cas pr√©c√©dent √† l'exception du dernier param√®tre, la **raison de l'arr√™t** si n'est plus `:normal` mais un tuple de la forme:

![](files/process-down-error.png)

```elixir
 {%RuntimeError{message: "This is a crash"}, []}
```

<!-- livebook:{"branch_parent_index":0} -->

## Exercice ‚Äì Calcul distribut√© tol√©rant aux pannes

Dans cet exercice, je vous donne un squelette de programme simple: il s'agit d'un programme qui calcule la somme des cubes de valeurs contenues dans des listes pass√©es en argument.

_prenez le temps de lire et comprendre ce code avant de passer √† la suite_ du TP !

```elixir
defmodule TP2Exercice1 do
  # Calcule la somme des cubes des sous-listes
  def sum_all(list_of_lists) do
    worker_pids =
      for list <- list_of_lists do
        # lance les sous-√¢ches
        spawn(TP2Exercice1, :sum_cubes_in_list, [self(), list])
      end

    for pid <- worker_pids do
      Process.monitor(pid)
    end

    # attend le r√©sultat de toutes les t√¢ches, et additionne le tout
    receive_results(worker_pids, 0)
  end

  # Calcule la somme des cubes dans une des listes
  def sum_cubes_in_list(master_pid, list) do
    # Comme des cubes dans la liste
    partial_sum =
      list
      |> Enum.map(fn x -> x ** 3 end)
      |> Enum.sum()

    # renvoie le r√©sultat au parent
    send(master_pid, {self(), partial_sum})
  end

  # Plus aucun worker en attente: on retourne le r√©sultat final
  defp receive_results([], sum), do: sum

  # Mise en attente de r√©ponse des workers
  defp receive_results(worker_pids, sum) do
    receive do
      {worker_pid, partial_sum} ->
        # on boucle:
        receive_results(
          # en enlevant le PID qui a r√©pondu de la liste
          List.delete(worker_pids, worker_pid),
          # et en ajoutant la somme partielle
          sum + partial_sum
        )          
    end
  end
end
```

```elixir
petite_liste_de_listes = [
  [ 1, 2, 3, 4, 5],
  [ 11, 12, 13 ],
  [ 155 ]
]

TP2Exercice1.sum_all(petite_liste_de_listes)
```

Par contre si on provoque un crash, par exemple en ins√©rant dans notre liste d'entr√©e une valeur qui n'est pas un nombre, plus rien ne fonctionne:

‚ö†Ô∏è **ATTENTION** la fonction ne retournant "jamais" votre cellule va se retrouv√©e "bloqu√©e". Il faudra arr√™ter l'ex√©cution avec le petit bouton "stop" en haut √† gauche de la cellule en question:

![](files/stop-button-cell.png)

Une fois que vous aurez fait votre essai **commentez la ligne d'appel de la fonction** pour ne pas bloquer le reste de la section.

Essayez sur la cellule suivante:

```elixir
liste_invalide = [
  [ 1, 2, 3, 4, 5],
  [ 11, 12, 13 ],
  [ 155, :pas_un_nombre ]
]

# üõë COMMENTEZ CETTE LIGNE TANT QUE VOUS N'AVEZ PAS R√âSOLU LE SOUCI
# TP2Exercice1.sum_all(liste_invalide)
```

### Premi√®re "solution" simple: ajouter un "timeout"

Jusqu'√† pr√©sent, nous avons utiliser [`receive/1`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#receive/1) dans sa forme la plus simple, qui _attend ind√©finiment_ une r√©ponse du serveur.

Il est cependant possible d'ajouter une clause `after` √† notre bloc `do`...`end` pour d√©cider ce qui doit se passer lorsqu'aucune clause ne "match" les messages attendus pendant un temps d√©termin√©.

Sur un exemple simple:

```elixir
receive do
  # üëá ce message n'arrivera jamais, vu qu'on ne va rien envoyer...
  {:message, msg} -> msg
after
  5000 ->
    IO.puts "Nous avons attendu 5 secondes sans recevoir de r√©ponse"
end
```

Notez que cette fonctionnalit√© peut √©galement √™tre utilis√©e pour _tester si l'on a des messages en attente_ sans bloquer le fonctionnement, par ex.:

```elixir
# envoyons-nous un message üíå
send(self(), {:message, "Coucou moi-m√™me"})

# Le message √©tant stock√© dans la "mailbox" de notre processus courant, nous pouvons le lire
# avec receive/1:
receive do
  {:message, msg} -> IO.puts("message dans la boite: #{msg}")
after
  0 -> IO.puts("Aucun message dans la boite")
end

# Notre mailbox est d√©sormais vide, mais gr√¢ce au "after 0" l'appel suivant ne va pas bloquer
# notre programme:
receive do
  {:message, msg} -> IO.puts("message dans la boite: #{msg}")
after
  0 -> IO.puts("Aucun message dans la boite")
end
```

**Corrigez le code de `TP2Exercice1` pour que le programme abandonne le calcul apr√®s quelques secondes, sans bloquer l'ex√©cution ind√©finiment**.

(_vous pouvez d√©commenter la ligne d'appel √† `TP2Exercice1.sum_all/1` dans la cellule de test_)

<!-- livebook:{"break_markdown":true} -->

### Une meilleure solution: d√©tecter les erreurs avec `Process.monitor/1`

Compter un "timeout" pour d√©tecter le plantage des sous-processus n'est pas une bonne solution √† long terme: par ex. si l'on souhaite effectuer un plus gros calcul, on pourrait arr√™ter avant la fin alors que le calcul est encore en cours !

Une meilleure solution sera donc d'utiliser un appel √† `Process.monitor/1` pour √™tre inform√© en cas de crash d'un de nos "processus workers".

**Modifiez le code du TP pour utiliser le monitoring des processus et g√©rer correctement le d√©faut d'un des processus-fils**

## Perfomance du calcul distribu√©

Voici un code de d√©part, exposant deux fonctions:

* la fonction `sum_all_parallel` qui reprend le code pr√©c√©dent, l√©g√®rement modifi√©
* la fonction `sum_all_sync` qui effectue le m√™me calcul, sans avoir recours √† des sous-processus

```elixir
defmodule TP2Exercice2 do
  def sum_all_sync(list_of_lists) do
    list_of_lists
    |> Enum.map(&sum_cubes_in_list/1)
    |> Enum.sum()
  end

  def sum_all_parallel(list_of_lists) do
    master_pid = self()

    for list <- list_of_lists do
      spawn(fn ->
        partial_result = sum_cubes_in_list(list)
        send(master_pid, {self(), partial_result})
      end)
    end
    |> receive_results()
  end

  # Calcule la som
  def sum_cubes_in_list(list) do
    list
    |> Enum.map(fn x -> x ** 3 end)
    |> Enum.sum()
  end

  # üí° Nouveaut√© : d√©claration d'une valeur par d√©faut pour le param√®tre "sum"
  defp receive_results(worker_pids, sum \\ 0)

  defp receive_results([], sum), do: sum

  defp receive_results(worker_pids, sum) do
    receive do
      {worker_pid, partial_sum} ->
        receive_results(
          List.delete(worker_pids, worker_pid),
          sum + partial_sum
        )
    end
  end
end
```

Nous allons maintenant utiliser la biblioth√®que [`Benchee`](https://hexdocs.pm/benchee) et plus particuli√®rement sa fonction [`Benchee.run/2`](https://hexdocs.pm/benchee/Benchee.html#run/2) pour comparer les performances de ces deux impl√©mentations sur des valeurs de test de petite taille.

* explorez ces r√©sultats, arrivez-vous √† les comprendre ?
* que constatez-vous ?

```elixir
petite_liste = [
  [1, 2, 3, 4, 5],
  [11, 12, 13],
  [155]
]

Benchee.run(
  %{
    "Version synchrone": &TP2Exercice2.sum_all_sync/1,
    "Version concurrente": &TP2Exercice2.sum_all_parallel/1
  },
  inputs: %{
    "petite liste" => petite_liste,
  }
)
```

Ce n'est pas tr√®s concluant: malgr√© tous nos efforts, la solution parall√®le semble plus lente que la simple version synchrone.

Mais de d√©sesp√©rons pas, il s'agit peut-√™tre d'un souci de _taille_ de l'√©chantillon consid√©r√© !
Pour en avoir le coeur net, nous allons re-tester notre code sur une liste de plus grande taille.

**G√©n√©rer un tableau de un million d'entr√©e, en cr√©ant une liste de 1000 listes de 1000 nombres al√©atoires**

<!-- livebook:{"break_markdown":true} -->

Vous pouvez utiliser pour cela:

* les [compr√©hensions `for`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1) d'√©lixir, associ√©es
* les "[range" `x..y`](https://hexdocs.pm/elixir/Range.html)"
* la fonction [`:rand.uniform/1`](https://www.erlang.org/doc/apps/stdlib/rand.html#uniform/1) d'Erlang

exemple:

<!-- livebook:{"force_markdown":true} -->

```elixir
for x <- 1..5 do
  x
end
[ 1, 2, 3, 4, 5 ]
```

<!-- livebook:{"break_markdown":true} -->

√† vous de jouer:

```elixir
# √Ä COMPL√âTER
grande_liste = []

Benchee.run(
  %{
    "Version synchrone": &TP2Exercice2.sum_all_sync/1,
    "Version concurrente": &TP2Exercice2.sum_all_parallel/1,
  },
  inputs: %{
    "grande liste" => grande_liste
  }
)
```

<!-- livebook:{"branch_parent_index":0} -->

## Processus li√©s

Il reste un cas de figure que nous n'avons pas encore envisag√©, et qui s'illustre facilement avec l'exemple suivant:

```elixir
spawn(fn ->
  # attente de 5 secondes
  Process.sleep(5000)
  
  IO.puts "hello"
end)

raise "Le processus parent est crash√©"
```

Vous pourrez observer le comportement suivant:

![](files/missing-link.png)

*Malgr√©* le crash du processus parent, le processus _enfant_ a continu√© son ex√©cution. Ce comportement est tout √† fait normal, les processus √©tant _ind√©pendants_.

L'ex√©cution peut s'illustrer comme suit:

```mermaid
sequenceDiagram
    autonumber
    participant P as Processus parent
    participant C as Processus enfant (non li√©)
    participant IO as Console

    P->>C: spawn(...)
    activate C
    Note right of C: ‚è≥ L‚Äôenfant dort 5 s

    P -x P: raise "Crash"  %% auto-terminaison du parent
    Note over P: Parent crash√©

    C->>IO: "hello"
    deactivate C
    Note over C: Pas de lien ‚Üí l‚Äôenfant continue
    
```

Pourtant, dans de nombreux cas, on ne souhaitera pas continuer l'ex√©cution des processus enfants dans le cas o√π le processus principal a crash√©.

La notion de **processus li√©s** va nous donner une solution simple √† cette probl√©matique:

```elixir
parent = spawn(fn ->
  spawn_link(fn ->
    # attente de 5 secondes
    Process.sleep(5000)

    IO.puts("hello")
  end)

  Process.sleep(1000)
  raise "D√©clenchement d'une RuntimeError"
end)

# on attend le message de "crash"
monitor_ref = Process.monitor(parent)
receive do
  {:DOWN, ^monitor_ref, :process, ^parent, {reason, _stack}} ->
    IO.inspect reason, label: "Le process parent a crash√© avec"
end
```

Cette fois, l'enfant s'est arr√™t√© automatiquement. Le "lien" entre l'enfant et le parent a permis de _faire suivre le message de crash_ du parent au processus enfant:

```mermaid
sequenceDiagram
    autonumber
    participant M as Moniteur (process courant)
    participant P as Parent
    participant C as Enfant (li√©)
    participant IO as Console

    M->>P: parent = spawn(...)
    activate P

    P->>C: spawn_link(...)
    activate C
    Note right of C: ‚è≥ L‚Äôenfant dort 5 s

    P -x P: raise "RuntimeError"  %% crash du parent
    Note over P,C: Lien actif ‚Üí le crash se propage

    C -x C: Exit (propagation du lien)  %% enfant termine aussi

    M->>M: monitor_ref = Process.monitor(parent)
    Note right of M: Re√ßoit {:DOWN, ^ref, :process, ^parent, {reason, _}}
```

<!-- livebook:{"break_markdown":true} -->

Pour cr√©er ce lien, **nous avons** simplement **remplac√© l'appel √† [`spawn/1`](https://hexdocs.pm/elixir/Kernel.html#spawn/1) par [`spawn_link/`](https://hexdocs.pm/elixir/Kernel.html#spawn_link/1)** qui lie les process parents et enfant.

<!-- livebook:{"break_markdown":true} -->

### Autres consid√©rations

* il existe des fonctions [`Process.link/1`](https://hexdocs.pm/elixir/Process.html#link/1) et [`Process.unlink/1`](https://hexdocs.pm/elixir/Process.html#unlink/1) qui permettent de li√©r / d√©-lier des processus d√©j√† lanc√©s
* par d√©faut, le lien est _bi-directionnel_: si un des processus enfants s'arr√™te sur une erreur, le processus parent sera √©galement impact√© ! <br> Cela peut √™tre souhait√©, mais si l'on souhaite avoir plus de contr√¥le ‚Äì par ex. un processus parent qui ne s'arr√™te pas mais puisse traiter les crash de ses processus enfants ‚Äì il faudra re-configurer le process parent avec [`Process.flag(:trap_exit, true)`](https://hexdocs.pm/elixir/Process.html#flag/2) ce qui va convertir l'√©v√®nement de "demande d'arr√™t de processus" en un message re√ßu dans la mailbox. <br> _Cette notion HPC ne sera pas approfondie dans ce cours: nous d√©couvrirons d'autres constructions pour organiser nos programmes avec une relation hi√©rarchique entre processus parents-enfants dans les notebooks √† venir_

<!-- livebook:{"branch_parent_index":0} -->

## Exercices suppl√©mentaires

Les petits exercices suivants sont _optionnels_ et uniquement l√† dans le but de _pratiquer_ la programmation Elixir, _si vous avez le temps_.

<!-- livebook:{"break_markdown":true} -->

### Attente de la fin de "n" processus enfants

Dans l'exercice suivant, vous devrez lancer

* lancer des processus enfants
* monitorer ces processus
* creer une fonction d'attente qui va attendre que tous les processus soient arr√™t√©s

Vous pouvez rpartir du code suivant

```elixir
defmodule TP2ExerciceOpt1 do
  def run do
    parent = self()

    # On lance 3 enfants avec des d√©lais diff√©rents
    delays = [{1, 200}, {2, 400}, {3, 150}]

    # TODO: d√©marrer les process enfants et retourner leurs PIDs
    #    les processus enfants:
    #    - attendens le temps (ms) pass√© en argument
    #    - affichent "Enfant <id> termin√©" √† la fin de l'ex√©cutino
    pids = [] 

    # TODO: monitorer tous les processus

    # TODO: lancer une boucle d'attente, qui s'arr√™te quand length(delays) 
    #       process enfants ont r√©pondu
  end
end
```

Pour tester votre impl√©mentation:

```elixir
TP2ExerciceOpt1.run()
```

üí° Vous pouvez √©galement modifier le code ci-dessous pour qu'il prenne en argument une liste de delays et cr√©e un nombre variable de process en cons√©quence, par ex.:

<!-- livebook:{"force_markdown":true} -->

```elixir
TP2ExerciceOpt1.run([200, 400, 150]) # √©quivalent √† la version pr√©c√©dente
```
