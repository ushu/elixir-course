# C2N4 â€“ Pour aller plus loin

```elixir
Mix.install([
  {:req, "~> 0.5.15"},
  {:kino, "~> 0.16.1"}
])

defmodule TP do
  def trace(trace_target \\ :all, trace_function) do
    Kino.Process.render_seq_trace(
      trace_target,
      trace_function,
      message_label: fn msg ->
        case msg do
          msg when is_binary(msg) -> {:ok, "MSG: #{msg}"}
          _ -> :continue
        end
      end
    )
  end
end
```

## Une nouvelle commande: Task.async_stream

Nous sommes presque au bout de notre exploration des primitives pour la concurrence, bravo !

Il est dÃ©sormais temps d'aborder une sÃ©rie de concepts plus avancÃ©s, Ã  commencer par la fonction [`Task.async_stream/3`](https://hexdocs.pm/elixir/Task.html#async_stream/3) qui permet de lancer des calculs en parallÃ¨le.

Commencez par examiner (et exÃ©cuter) le code suivant:

```elixir
inputs = 1..12

slow_cube = fn x ->
  Process.sleep(100 + :rand.uniform(150)) # on simule une attente de durÃ©e alÃ©atoire
  x * x * x
end

# TP.trace(fn ->
  inputs
  |> Task.async_stream(slow_cube, max_concurrency: 4, timeout: 2_000)
  |> Enum.to_list()
# end)
```

Ces quelques lignes ont:

* lancÃ© une sÃ©rie de calculs (`12` en tout) en parallÃ¨le
* rÃ©cupÃ©rer les rÃ©sultats retournÃ©s par tous les processus
* retourner tous ces rÃ©sultats dans une liste

Tout cela est Ã©quivalent au programme beaucoup plus complexe que nous avions Ã©crit dans les premiers notebooks, avec en plus:

* une gestion de la limite du nombre de processus enfants s'exÃ©cutant en parallÃ¨le (option  `max_concurrency:`)
* une gestion du temps limite d'exÃ©cution (option `timeout:`)

<!-- livebook:{"break_markdown":true} -->

ğŸ’¡ Cette fonction retourne un nouveau type d'objet que nous n'avions pas encore vu: un [`Stream`](https://hexdocs.pm/elixir/enumerable-and-streams.html#streams). Il s'agit d'objet ressemblant Ã  des listes mais dont l'Ã©valuation est "paresseuse".

Nous ne creuseront pas beaucoup ces notions Ã  ce stade, mais ce que vous devez retenir c'est qu'on peut les passer Ã  une boucle [`for`](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1) ou aux fonctions du module [`Enum`](https://hexdocs.pm/elixir/Enum.html) de la mÃªme faÃ§on qu'une liste.

Ainsi, nous pourrions rÃ©-Ã©crire notre exemple ainsi:

```elixir
    # lance les streams et gÃ©nÃ¨re une "stream" de tÃ¢ches
for tasks <- Task.async_stream(inputs, slow_cube, max_concurrency: 4, timeout: 2_000),
    # les rÃ©sultats sont retournÃ©s sous forme de tuples {:ok, value}, on pattern-match
    {:ok, result} = tasks do
  result
end
```

## Exercice: chargement de requÃªtes depuis internet

Nous allons mettre Ã  profit les constructions prÃ©sentÃ©es ci-dessus pour charger des informations depuis internet.

```elixir
urls = [
  "https://swapi.info/api/people/1",
  "https://swapi.info/api/people/2",
  "https://swapi.info/api/people/3",
  "https://swapi.info/api/people/100",
]

# ComplÃ©tez le code ci-dessous
for url <- urls do
  # 1. lancez des tÃ¢ches pour tÃ©lÃ©charger les Ã©lÃ©ments ci-dessus (avec Req.get!/1)
  # 2. ne gardez que les rÃ©ponses dont le status est "200" (ce qui signifient qu'elles ont rÃ©ussi)
  # 3. extrayez le nom du personnage depuis le body
  url
end
```

## Le GenServer

Il est souvent nÃ©cessaire de lancer des processus qui attendent et rÃ©pondent Ã  des messages en Elixir. Cependant, la structure rÃ©cursive qui boucle sur "`receive`" n'est pas trÃ¨s pratique.

Afin d'abstraire ces concepts, Elixir dispose du concept de [`GenServer`](https://hexdocs.pm/elixir/1.18.3/GenServer.html), qui sont des modules spÃ©cialisÃ©s et dÃ©finis comme suit:

```elixir
defmodule MonPremierGenserver do
  def init(_) do
    {:ok, []}
  end

  # ğŸ§™â€â™‚ï¸ DÃ©clenchÃ© Ã  une appel GenServer.cast(pid, {:push, val})
  #    le client continue sans attendre de rÃ©ponse (d'oÃ¹ le :noreply)
  def handle_cast({:push, element}, state) do
    new_state = [element | state]
    {:noreply, new_state}
  end

  # ğŸ“ DÃ©clenchÃ© Ã  une appel GenServer.call(pid, {:push, val})
  #    l'appelant arrÃªte son exÃ©cution dans l'attente d'une rÃ©ponse
  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    # to_caller contient la rÃ©ponse qui sera renvoyÃ©e au client
    {:reply, to_caller, new_state}
  end
end
```

Dans ce module, nous avons dÃ©fini 3 mÃ©thods:

* une **fonction [`init/1`](https://hexdocs.pm/elixir/GenServer.html#c:init/1)** qui prend les arguments passÃ©s au dÃ©marrage, et doit retourner un tuple `{:ok, state}` oÃ¹ `state` est l'"Ã©tat" du processus (c-Ã -d. les informations stockÃ©es dans le processus)
* une **fonction [`handle_cast/2`](https://hexdocs.pm/elixir/GenServer.html#c:handle_cast/2)** qui recevra les messages envoyÃ©s par l'appel [`GenServer.cast/2`](https://hexdocs.pm/elixir/GenServer.html#cast/2). Cette fonction doit renvoyer `{:noreply, state}` oÃ¹ `state` est l'Ã©tat du processus, mis Ã  jour en rÃ©action au message reÃ§u
* une **fonction [`handle_call/3`](https://hexdocs.pm/elixir/GenServer.html#c:handle_call/3)** qui recevra les messages envoyÃ©s par l'appel [`GenServer.call/2`](https://hexdocs.pm/elixir/GenServer.html#call/3). Cette fonction doit renvoyer `{:reply, rÃ©ponse, state}` oÃ¹ `rÃ©ponse` est le message renvoyÃ© Ã  l'appelant et `state` est l'Ã©tat du processus, mis Ã  jour en rÃ©action au message reÃ§u

```elixir
{:ok, stack} = GenServer.start_link(MonPremierGenserver, :ignored_arg)

# On rajoute des Ã©lÃ©ments Ã  notre tas
GenServer.cast(stack, {:push, 1})
GenServer.cast(stack, {:push, 2})
GenServer.cast(stack, {:push, 3})

# On lit les Ã©lÃ©ments stockÃ©s
IO.puts GenServer.call(stack, :pop)
IO.puts GenServer.call(stack, :pop)
IO.puts GenServer.call(stack, :pop)

# On termine ce processus sans erreur (reason = :normal)
GenServer.stop(stack)
```

on peut illustrer le fonctionnement global comme suit:

```mermaid
sequenceDiagram
participant Client
participant GS as MonPremierGenserver (GenServer)

Client->>GS: GenServer.start_link(MonPremierGenserver, [])
activate GS
Note right of GS: init(_) -> {:ok, []}<br/>state = []

Client-->>GS: GenServer.cast(stack, {:push, 1})
Note over Client,GS: handle_cast({:push, 1}, state)
GS->>GS: state = [1]

Client-->>GS: GenServer.cast(stack, {:push, 2})
Note over Client,GS: handle_cast({:push, 2}, state)
GS->>GS: state = [2, 1]

Client-->>GS: GenServer.cast(stack, {:push, 3})
Note over Client,GS: handle_cast({:push, 3}, state)
GS->>GS: state = [3, 2, 1]

Client->>+GS: GenServer.call(stack, :pop)
Note over Client,GS: handle_call(:pop, _from, state)
GS-->>-Client: {:reply, 3}
GS->>GS: state = [2, 1]

Client->>+GS: GenServer.call(stack, :pop)
Note over Client,GS: handle_call(:pop, _from, state)
GS-->>-Client: {:reply, 2}
GS->>GS: state = [1]

Client->>+GS: GenServer.call(stack, :pop)
Note over Client,GS: handle_call(:pop, _from, state)
GS-->>-Client: {:reply, 1}
GS->>GS: state = []

deactivate GS
```

<!-- livebook:{"break_markdown":true} -->

### DÃ©finition d'une "interface client"

Vous verrez souvent des modules `GenServer` dÃ©finissant dÃ©finissant des fonctions pour le "client" (le client qui envoie les message au `GenServer`) et une pour le "serveur" (le process qui exÃ©cute le `GenServer` lui-mÃªme).

Voici par ex. une faÃ§on de modifier notre exemple prÃ©cÃ©dent:

```elixir
defmodule MonStack do  
  ###
  # API CLIENT
  ###

  def start_link(initial_state \\ []), do: 
    # Ici __MODULE__ est le nom du module courant, soit "MonStack"
    GenServer.start_link(__MODULE__, initial_state)

  def push(pid, value), do:
    GenServer.cast(pid, {:push, value})

  def pop(pid), do:
    GenServer.call(pid, :pop)

  ###
  # API SERVEUR
  ###
  
  def init(initial_state), do: 
    {:ok, initial_state}

  def handle_cast({:push, element}, state) do
    new_state = [element | state]
    {:noreply, new_state}
  end

  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    {:reply, to_caller, new_state}
  end
end
```

Ce qui permet d'avoir un code plus expressif:

```elixir
{:ok, stack} = MonStack.start_link()

MonStack.push(stack, 1)
MonStack.push(stack, 2)
MonStack.push(stack, 3)

IO.puts MonStack.pop(stack)
IO.puts MonStack.pop(stack)
IO.puts MonStack.pop(stack)
```

### Autres messages envoyÃ©s Ã  un `GenServer`

Il est toujours possible d'envoyer des messages _directement_ Ã  un GenServer â€“ c-Ã -d. en dehors de [`call/2`](https://hexdocs.pm/elixir/GenServer.html#call/3) et [`cast/2`](https://hexdocs.pm/elixir/GenServer.html#cast/2) â€“ via `send`.

Ces messages arrivent dans un autre callback: [`handle_info/2`](https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2)

```elixir
defmodule CallMe do

  def init(_), do:
    {:ok, :state_not_used}

  def handle_info(msg, state) do
    IO.puts "Message reÃ§u par #{inspect(self())}: #{msg}"
    {:noreply, state}
  end
end
```

```elixir
{:ok, pid} = GenServer.start_link(CallMe, nil, 
  # âœ¨ NouveautÃ©: on donne un "nom" Ã  notre process qui est dÃ©marrÃ©
  name: CallMe)
  
TP.trace([self(), pid], fn ->

  # on envoie un message via send(pid, message)
  IO.puts("Envoi du message Ã  #{inspect(pid)}")
  send(pid, "Salut ğŸ‘‹")

  Process.sleep(500) # ğŸ‘ˆ attente que tous les messages soient envoyÃ©s pour le trace()  
end)

GenServer.stop(CallMe) # ğŸ‘ˆ On peut passer le nom aux appels au lieu du pid
```

Cette faÃ§on de faire peut Ã©galement Ãªtre utilisÃ©e Ã  l'intÃ©rieur mÃªme du module `GenServer`, par exemple pour s'appeler lui-mÃªme, dÃ©mo:

```elixir
defmodule SimpleTicker do
  def init(delay_ms) do
    # S'envoie un message Ã  lui-mÃªme aprÃ¨s delay_ms millisecondes
    Process.send_after(self(), :tick, delay_ms)
    {:ok, delay_ms}
  end

  def handle_info(:tick, delay_ms) do
    IO.puts "Tick !"
    Process.send_after(self(), :tick, delay_ms)
    {:noreply, delay_ms}
  end
end
```

```elixir
{:ok, pid} = GenServer.start_link(SimpleTicker, 500)

Process.sleep(3_000) # ğŸ‘ˆ attente de 3 secondes, le temps que le ticker tourne plusieurs fois

GenServer.stop(pid)
```

## La supervision â€“ principes gÃ©nÃ©raux

Nous avons dÃ©couvert comment les processus Elixir peuvent se monitorer les uns les autres. Ces fonctionnalitÃ©s permettent dÃ©finir des stratÃ©gies de "supervision", avec un processus principal qui monitore et relance les processus enfants au fur et Ã  mesure.

Le module [`Supervisor`](https://hexdocs.pm/elixir/1.18.3/Supervisor.html) d'elixir propose une sÃ©rie de fonctions spÃ©cifiques pour gÃ©rer les cas les plus courants.

ğŸ’¡ Pour que ces processus puissent Ãªtre lancÃ©s, relancÃ©s et arrÃªtÃ©s correctment par les fonctions du module `Supervisor`, ils doivent Ãªtre dÃ©finis en tant que `GenServer`s.

<!-- livebook:{"break_markdown":true} -->

### Les stratÃ©gies pour relancer les processus

En cas d'arrÃªt des processus fils, ils sont relancÃ©s en suivant une des logiques suivantes (caractÃ©risÃ©es par leur nom):

* `:one_for_one`
* `:one_for_all`
* `:rest_for_one`

<!-- livebook:{"break_markdown":true} -->

#### StratÃ©gie `:one_for_one`

Le superviseur relance le processus enfant qui s'est arrÃªtÃ©:

```mermaid
flowchart LR
  S[Supervisor]:::sup --> A[Child A]
  S --> B[Child B]
  S --> C[Child C]

  classDef sup fill:#eef,stroke:#36c,stroke-width:2px;
  classDef dead fill:#fee,stroke:#c33,stroke-width:2px;

  %% Crash de B
  B -. crash .-> Bx((B redÃ©marrÃ©))
  class Bx dead
```

<!-- livebook:{"break_markdown":true} -->

#### StratÃ©gie `:one_for_all`

```mermaid
flowchart LR
  S[Supervisor]:::sup --> A[Child A]
  S --> B[Child B]
  S --> C[Child C]

  classDef sup fill:#eef,stroke:#36c,stroke-width:2px;
  classDef reset fill:#ffd,stroke:#c90,stroke-width:2px;

  B -. crash .-> All((Tous redÃ©marrÃ©s))
  class A reset
  class C reset
  class B reset
```

<!-- livebook:{"break_markdown":true} -->

#### StratÃ©gie `:rest_for_one`

```mermaid
flowchart TB
  S[Supervisor]:::sup --> A[Child A]
  S --> B[Child B]
  S --> C[Child C]

  classDef sup fill:#eef,stroke:#36c,stroke-width:2px;
  classDef reset fill:#ffd,stroke:#c90,stroke-width:2px;

  B -. crash .-> R((B et C redÃ©marrÃ©s, A conservÃ©))
  class R reset
```

## La supervision â€“ en pratique

Passons Ã  un aspect plus pratique de la supervision. Nous allons Ã©crire un module `TStackicker` qui est une extension du `MonStack` dÃ©fini plus tÃ´t:

_les modifications par rapport au code initial sont notÃ©s par un symbole ğŸ”_

```elixir
defmodule Stack do
  
  # API CLIENT

  # ğŸ” Au dÃ©marrage on passe en argument un "nom d'enregistrement" pour appeler ce GenServer
  def start_link(name),
    do: GenServer.start_link(__MODULE__, [], name: name)

  def push(stack, value), do: GenServer.cast(stack, {:push, value})
  
  def pop(stack), do: GenServer.call(stack, :pop)

  # API SERVEUR

  def init(initial_state), do: {:ok, initial_state}

  def handle_cast({:push, element}, state) do
    new_state = [element | state]
    {:noreply, new_state}
  end

  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    {:reply, to_caller, new_state}
  end

  # ğŸ” On ajoute une commande pour "planter" le Stack Ã  la demande
  def handle_info(:boom, state) do
    raise "BOOM"
    {:noreply, state}
  end
end
```

```elixir
{:ok, pid} = Supervisor.start_link(
  [
    %{
      id: Stack1, # on dÃ©marre 
      start: {Stack, :start_link, [Stack1]}
    },
    %{
      id: Stack2,
      start: {Stack, :start_link, [Stack2]}
    }
  ],
  strategy: :one_for_all
)

# Affichons un graphique reprÃ©sentant l'arborescence de supervision:
Kino.Process.render_sup_tree(pid)

# ğŸ‘‡ dÃ©but des tests

# Utilisation normale du Stack
IO.inspect GenServer.whereis(Stack1), label: "Stack1 tourne dans le pid"
IO.inspect GenServer.whereis(Stack2), label: "Stack2 tourne dans le pid"

Stack.push(Stack1, 1)
Stack.push(Stack1, 2)
Stack.push(Stack1, 3)

IO.puts Stack.pop(Stack1)
IO.puts Stack.pop(Stack1)
IO.puts Stack.pop(Stack1)

# Maintenant va crasher notre Stack
IO.puts "CRASH du processus Stack1"
send(Stack1, :boom)
Process.sleep(100) # et on laisse du temps au Superviseur pour re-lancer notre Stack

# On peut rÃ©-utiliser le Stack dÃ©sormais
IO.inspect GenServer.whereis(Stack1), label: "Stack1 tourne dans le pid"
Stack.push(Stack1, 1)
IO.puts Stack.pop(Stack1)

# On peut Ã©galement appeler Stack2
IO.inspect GenServer.whereis(Stack2), label: "Stack2 tourne dans le pid"
Stack.push(Stack2, 11)
Stack.push(Stack2, 22)

IO.puts Stack.pop(Stack2)
IO.puts Stack.pop(Stack2)



Supervisor.stop(pid)
```

ğŸ’¡ Si vous changez la stratÃ©gie de supervision de `:one_for_one` vers `:one_for_all` vous constaterez que le Stack2 est Ã©galement re-dÃ©marrÃ©: son PID change.
